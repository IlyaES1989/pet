""" Prepare class"""
from io import BytesIO

from openpyxl import (
    Workbook,
    load_workbook,
)
from openpyxl.cell import WriteOnlyCell
from openpyxl.styles import PatternFill

from re import search

from zipfile import (
    ZipFile,
    ZIP_DEFLATED,
)


class Prepare:

    def __init__(self):
        self.path = ''
        self.file = ''
        self.template_dict = {}
        self.file_tag = ''
        self.workbook = ''
        self.sheet_r = ''
        self.head_pos = []
        self.head_value = []
        self.not_empty = set()

    def fix_error(self):
        """
        Solve the problem with opening files generated by the 1C program.
        # The Openpyxl library requires an xml-file named 'xl/sharedStrings.xml' in the Excel file,
        # whereas the 1C program sometimes generates an Excel file with 'xl/SharedStrings.xml'.
        This method renames the xml file, eliminating this mismatch.
        """
        source = ZipFile(self.file, 'r')
        target = ZipFile(self.file, 'w', ZIP_DEFLATED)

        for file in source.filelist:
            if file.filename != 'xl/SharedStrings.xml':
                target.writestr(file.filename, source.read(file.filename))
            else:
                target.writestr('xl/sharedStrings.xml', source.read(name=file.filename))
        target.close()
        source.close()

    def reader(self, read_only=True, sheet='TDSheet', file_name=None):
        """ Open Excel-file and activate sheet. """
        if file_name is None:
            file_name = self.file
        self.workbook = load_workbook(filename=file_name, read_only=read_only)
        self.sheet_r = self.workbook[sheet]

    def determ_file(self):
        """
        Assign a tag (self.file_tag) to a file according to self.template_dict
        or 'EMPTY_TAG' if nothing is found.
         """
        cache_list = []
        length = []
        for key in self.template_dict.keys():
            cache = []
            for val in self.template_dict[key]:
                switch = 0
                for row in self.sheet_r.iter_rows(max_row=100):
                    if switch != 0:
                        break
                    else:
                        for cell in row:
                            result = search(val, str(cell.value))
                            if result is not None and switch == 0:
                                cache.append(result)
                                switch += 1

            if len(cache) == len(self.template_dict[key]):
                cache_list.append(key)
        if cache_list:
            for key in cache_list:
                length.append(len(self.template_dict[key]))
            if length != 0:
                self.file_tag = cache_list[length.index(max(length))]
        else:
            self.file_tag = 'EMPTY_TAG'

    def find_head(self):
        """
        Find head of table, if this head have color background.
        Write the numbers of head-including rows to self.head_pos.
        """
        switch = [0, 0]
        for row in self.sheet_r.rows:
            if switch == [1, 0]:
                break
            switch[0] = switch[1]

            try:
                if row[0].fill.start_color.index != '00000000':
                    switch[1] = 1
                    self.head_pos.append(row[0].row)
                else:
                    switch[1] = 0
            except AttributeError:
                pass

    def find_group(self):
        """Check if the rows of group by cities are in the self.head_pos and correct it."""
        cache = []
        for row in self.sheet_r.iter_rows(min_row=self.head_pos[-1], max_row=self.head_pos[-1]):
            for cell in row:
                if cell.value is None:
                    cache.append(0)
                else:
                    cache.append(1)
        # The rows of group by cities includes the value only in first and last column.
        if cache[0]+cache[-1] == 2 and sum(cache[1:-1]) == 0:
            del(self.head_pos[-1])

    def del_empty(self):
        """ Write numbers of the not empty columns to self.not_empty."""
        for row in self.sheet_r.iter_rows(min_row=self.head_pos[0], max_row=self.head_pos[-1]):
            for cell in row:
                try:
                    if cell.fill.start_color.index != '00000000':
                        if cell.value is not None:
                            self.not_empty.add(cell.column)
                except AttributeError:
                    pass

    def change_head(self):
        """ Convert multirow head of the table to one-row one and writes it to self.head_value."""
        for row in self.sheet_r.iter_rows(min_row=self.head_pos[0],
                                          max_row=self.head_pos[-1]):
            sub_head = []
            for cell in row:
                try:
                    if cell.column in self.not_empty:
                        sub_head.append(cell.value)
                except AttributeError:
                    pass
            self.head_value.append(sub_head)
        for i in range(1, len(self.head_value)):
            for j in range(len(self.head_value[i])):
                if self.head_value[i][j] is None:
                    self.head_value[i][j] = self.head_value[i - 1][j]

        for i in range(len(self.head_value)):
            for j in range(len(self.head_value[i])):
                if self.head_value[i][j] is None:
                    self.head_value[i][j] = self.head_value[i][j - 1]

        for i in range(1, len(self.head_value)):
            for j in range(len(self.head_value[i])):
                if self.head_value[i][j] != self.head_value[i - 1][j]:
                    self.head_value[i][j] = str(self.head_value[i - 1][j]) + '.' + str(self.head_value[i][j])

        self.head_value = self.head_value[-1]

    def writer(self, color='FFC0BCB1'):
        """Create new book without empty columns, multirow head, and different stiles of the cells.
        :return BytesIO object."""

        virtual_workbook = BytesIO()
        writer = Workbook()
        sheet_w = writer.active
        sheet_w.title = 'TDSheet'

        cache = []
        fill_style = PatternFill(start_color=color, fill_type='solid')

        for cell in self.head_value:
            cell_r = WriteOnlyCell(sheet_w, value='%s' % cell)
            cell_r.fill = fill_style
            cache.append(cell_r)
        sheet_w.append(cache)

        for row in self.sheet_r.iter_rows(min_row=self.head_pos[-1] + 1):
            cache = []
            for cell in row:

                try:
                    if cell.column in self.not_empty:
                        cache.append(cell.value)
                except AttributeError:
                    pass
            sheet_w.append(cache)

        writer.save(virtual_workbook)

        return virtual_workbook

    def close_reader(self):
        self.workbook.close()

    def _get_row_value(self):
        """
        Iterate document row by row and return value of cells like the list,
        where number of column accords index of the list.
         """
        for row in self.sheet_r.rows:
            val = [None, ]
            for cell in row:
                val.append(cell.value)
            yield val

    def get_data(self, target, sought_column, returned_column, func_name):
        """
        :param target: dict,
                where {'key_word' : [ ('searching value','searching value in next column'), ('ect.', 'etc.')]}.
        :param sought_column: list, including numbers of column where must be searching values.
            Length of this list and length of tuples with searching values must be equal.
        :param returned_column: list, including numbers of returned columns.
        :param func_name: str, name of aggregate functions.
        :return dict, where keys corresponds with  target attributes keys, values are aggregate functions results.
        """
        func_dict = {
            'SUM': sum,
            'COUNT': len,
        }
        try:
            func = func_dict[func_name]
        except KeyError:
            raise KeyError('func_name argument must be one of %s' % list(func_dict.keys()))

        result = {}
        row = self._get_row_value()
        try:
            while True:
                value_list = next(row)
                for key in target:
                    for searching_value in target[key]:
                        a = [search(val, str(value_list[col])) for val, col in zip(searching_value, sought_column)]
                        if None not in a:
                            sub_result = func([float(value_list[col]) for col in returned_column if value_list[col]])
                            result[key] = result.get(key, 0) + sub_result

        except StopIteration:
            return result

    def get_data_by_number(self, start_row=1, max_row=1, start_column=1, max_column=1):
        """
        Get data by number of rows and columns
        :return list, including other lists with getting values. If length of returning list is equal 1,
         return value as str.
        """
        data = []
        for row in self.sheet_r.iter_rows(min_row=start_row, max_row=max_row,
                                          min_col=start_column, max_col=max_column):
            cache = []
            for cell in row:
                cache.append(cell.value)
            data.append(cache)
        if len(data) == 1:
            return data[0][0]
        else:
            return data

